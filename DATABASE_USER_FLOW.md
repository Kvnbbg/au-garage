# Database Schema and User Flow Documentation

This document outlines the database schema of the Garage V. Parrot Management System, focusing on how user data and roles are managed, and describes key user flows related to authentication, authorization, and data interaction.

## I. Database Schema (SQLAlchemy ORM)

The application uses Flask-SQLAlchemy as its Object-Relational Mapper (ORM) to interact with the database (typically PostgreSQL in production, SQLite in development). The following are the primary models involved in user management and activity tracking:

### 1. `User` Model
   - **Purpose:** Represents registered users of the application.
   - **Fields/Columns:**
     - `id` (Integer, Primary Key): Unique identifier for the user.
     - `username` (String, Unique, Not Nullable): User's chosen username.
     - `email` (String, Unique, Not Nullable): User's email address.
     - `password_hash` (String): Hashed version of the user's password for security.
     - `role_id` (Integer, Foreign Key to `roles.id`): Identifier for the user's assigned role.
     - `last_seen` (DateTime, Nullable): Timestamp of the user's last activity (Note: This field was mentioned in the prompt but might not be explicitly implemented in the current codebase provided earlier. If present, it would track user activity).
     - `about_me` (Text, Nullable): A short description about the user (Note: Similar to `last_seen`, this might be a desired field not yet in the provided code).
   - **Relationships:**
     - `role` (Many-to-One with `Role`): Accesses the `Role` object associated with the user via `role_id`. Established by `Role.users` backref.
     - `activity_logs` (One-to-Many with `ActivityLog`): A list of activity logs generated by this user. Established by `ActivityLog.user` backref.
     - `cvs` (One-to-Many with `CV`): A list of CVs uploaded by this user. Established by `CV.user` backref (Note: `CV` model implementation was blocked in a previous step due to environment issues, but is documented here as per overall design intent).

### 2. `Role` Model
   - **Purpose:** Defines different user roles within the application, each with specific permissions and UI customizations.
   - **Fields/Columns:**
     - `id` (Integer, Primary Key): Unique identifier for the role.
     - `name` (String, Unique, Not Nullable): Name of the role (e.g., 'Admin', 'Client', 'Worker', 'Maintenance').
     - `color_code` (String, Nullable): Hex color code associated with the role for UI theming (e.g., navbar color).
     - `hashtag` (String, Nullable): A short hashtag associated with the role for display (e.g., #admin).
   - **Relationships:**
     - `users` (One-to-Many with `User`): A list of users assigned to this role. Establishes the `User.role` backref.

### 3. `ActivityLog` Model
   - **Purpose:** Records significant actions performed by users for auditing or tracking purposes.
   - **Fields/Columns:**
     - `activity_id` (Integer, Primary Key): Unique identifier for the log entry.
     - `user_id` (Integer, Foreign Key to `users.id`): The user who performed the activity.
     - `activity_data` (String): Description of the activity performed.
     - `timestamp` (DateTime, Default `datetime.utcnow`): Time the activity was logged.
   - **Relationships:**
     - `user` (Many-to-One with `User`): The user object associated with this activity log.

### 4. `VisitCount` Model
   - **Purpose:** Tracks the number of visits for users (identified by a persistent cookie or user ID if logged in).
   - **Fields/Columns:**
     - `id` (Integer, Primary Key): Unique identifier for the visit count record.
     - `user_id_str` (String, Unique, Not Nullable): A string identifier for the user (can be an anonymous ID from a cookie or the actual user ID if logged in).
     - `visits` (Integer, Default 1): The number of visits recorded for this identifier.
   - **Relationships:**
     - None explicitly defined with other models in a direct SQLAlchemy relationship, but `user_id_str` can be correlated with `User.id` if the user is authenticated.

## II. Key User Flows

### 1. User Registration
   - **Form:** `RegisterForm` (from `app/auth/forms.py`) is used, collecting username, email (optional), password, and password confirmation.
   - **Process:**
     1. Upon valid submission, a new `User` object is created.
     2. The provided password is
        hashed using `user.set_password()` (which internally uses `generate_password_hash`).
     3. The 'Client' role is fetched from the `Role` table using `Role.find_by_name('Client')`.
     4. The `id` of this 'Client' role is assigned to the new `User`'s `role_id` attribute.
     5. The new `User` object (with `username`, `email`, `password_hash`, and `role_id`) is added to the database session and committed.
     6. The new user is automatically logged in using Flask-Login's `login_user(new_user)`.
     7. The user is redirected to their dashboard (`url_for('auth.dashboard')`).
   - **Database Impact:** A new row is created in the `users` table.

### 2. User Login
   - **Form:** `LoginForm` (from `app/auth/forms.py`) is used, collecting username and password. It also includes a "Remember Me" option.
   - **Process:**
     1. User submits credentials.
     2. The system attempts to find the user by username using `User.find_by_username()`.
     3. If the user exists, the provided password is checked against the stored `password_hash` using `user.check_password()` (which internally uses `check_password_hash`).
     4. If authentication is successful, a session is created for the user using Flask-Login's `login_user(user, remember=form.remember_me.data)`.
     5. The user is redirected to the page they were trying to access (if `next` parameter is present and safe) or to their dashboard (`url_for('auth.dashboard')`).
   - **Database Impact:** Primarily read operations on the `users` table. `last_seen` might be updated if implemented.

### 3. Role-Based Access & UI Personalization
   - **User Data:** Flask-Login's `current_user` proxy provides access to the logged-in `User` object (or an anonymous user object if not logged in).
   - **Context Processor:** The `inject_user_role_info` function (defined in `app/__init__.py` with `@app.context_processor`) makes the current user's `Role` object (if any) available in all templates as `user_role`. It fetches this via `current_user.role`.
   - **UI Customization:**
     - **Navbar Color:** In `app/templates/base.html`, the navbar's background color is dynamically set using `user_role.color_code` if available (`<nav ... {% if user_role and user_role.color_code %}style="background-color: {{ user_role.color_code }} !important;"{% endif %}>`).
     - **Hashtag Display:** Also in `base.html`, the `user_role.hashtag` is displayed next to the username in the profile link, if available.
     - **Dashboard Menus:** In `app/templates/dashboard.html`, different menu items are rendered based on `user_role.name` using Jinja2 conditionals (e.g., `{% if user_role.name == 'Admin' %}`).

### 4. Admin User Role Management
   - **Routes:**
     - `/admin/users` (`auth.admin_user_list`): Displays a list of all users. Accessible only to Admins.
     - `/admin/edit_user_role/<user_id>` (`auth.admin_edit_user_role`): Allows an Admin to edit the role of a specific user.
   - **Form:** `AdminEditUserRoleForm` (from `app/auth/forms.py`) is used, which provides a `SelectField` populated with all available roles.
   - **Process:**
     1. Admin navigates to the user list.
     2. Admin clicks "Edit Role" for a specific user, navigating to the edit page.
     3. The form is pre-populated with the user's current role.
     4. Admin selects a new role from the dropdown and submits.
     5. The route updates the `user_to_edit.role_id` with the selected role's ID.
     6. The change is committed to the database (`db.session.commit()`).
     7. Admin is redirected back to the user list with a success message.
   - **Database Impact:** Updates the `role_id` field for a specific user in the `users` table.

## III. Data Initialization

- **Role Population:** The `flask init-roles` command-line interface (CLI) command, defined in `app/__init__.py`, calls the `init_roles()` function from `app/models.py`.
- This function ensures that predefined roles ('Admin', 'Client', 'Worker', 'Maintenance') with their associated `name`, `color_code`, and `hashtag` are present in the `roles` table. It creates them if they don't exist or updates their attributes if they do. This is crucial for the proper functioning of role-based features.
